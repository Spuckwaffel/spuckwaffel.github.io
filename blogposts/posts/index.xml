<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Spuckwaffels Blog</title>
    <link>https://spuckwaffel.com/blogposts/posts/</link>
    <description>Recent content in Posts on Spuckwaffels Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Spuckwaffel</copyright>
    <lastBuildDate>Tue, 24 Oct 2023 00:57:31 +0200</lastBuildDate><atom:link href="https://spuckwaffel.com/blogposts/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RE-Invent: Byte Patching functions for unfair advantages</title>
      <link>https://spuckwaffel.com/blogposts/posts/byte-patching/</link>
      <pubDate>Tue, 24 Oct 2023 00:57:31 +0200</pubDate>
      
      <guid>https://spuckwaffel.com/blogposts/posts/byte-patching/</guid>
      <description>Disclaimer The RE-Invent blog posts are designed to break down complex information into simpler terms, specifically for beginners learning the basics of Reverse Engineering. These posts are strictly for educational and experimental use and are not intended to target any software. Please ensure to use this knowledge responsibly and in accordance with ethical and legal standards.
Introduction This article expects basic knowledge about sections in applications (.text, .data), offsets, assembly and debugging knowledge.</description>
      <content>&lt;h2 id=&#34;disclaimer&#34;&gt;Disclaimer&lt;/h2&gt;
&lt;p&gt;The RE-Invent blog posts are designed to break down complex information into simpler terms, specifically for beginners learning the basics of Reverse Engineering. These posts are strictly for educational and experimental use and are not intended to target any software. Please ensure to use this knowledge responsibly and in accordance with ethical and legal standards.&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This article expects basic knowledge about sections in applications (&lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;), offsets, assembly and debugging knowledge.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Many of us have experienced being stuck in a video game, unable to progress due to resource limitations or not having enough coins to purchase valuable items. Similarly, if you&amp;rsquo;ve ever wanted to use a program beyond its free trial period without paying, you might have wondered about the complexity of manipulating the program to achieve your goal. Large programs can be very intricate, making it challenging for beginners to locate the function responsible for time or coin management. So, where do you begin, and once you succeed, how can you create a program that automatically applies these changes? Let&amp;rsquo;s explore this.&lt;/p&gt;
&lt;h2 id=&#34;goals&#34;&gt;Goals&lt;/h2&gt;
&lt;p&gt;Lets split up our final goal into smaller sections.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Finding the corresponding function and assembly code that checks the coin balance or the time via debugging or reading the programs&amp;rsquo; code&lt;/li&gt;
&lt;li&gt;Creating a pattern so we always find the bytes we have to replace&lt;/li&gt;
&lt;li&gt;Writing a program to write the bytes&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;finding-the-function&#34;&gt;Finding the function&lt;/h2&gt;
&lt;p&gt;To begin, let&amp;rsquo;s first figure out where we need to make changes to a function to achieve the desired result. Consider a program that verifies whether you have sufficient funds to purchase the master sword.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//target price stored somewhere in memory
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; masterSwordPrice &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5000&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//function that checks if the balance is enough to buy the sword
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hasEnoughMoney&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; balance)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (balance &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; masterSwordPrice)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;buyMasterSword&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//get our current balance
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; currentBalance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(hasEnoughMoney(currentBalance))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		puts(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Buying the sword...&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		puts(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Not enough money...&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If a user lacks the required funds, they can&amp;rsquo;t purchase the master sword and will receive the message &amp;ldquo;Not enough money&amp;hellip;&amp;rdquo; instead. The critical part here is the &lt;code&gt;hasEnoughMoney&lt;/code&gt; function, which checks if the user has sufficient funds to buy the sword at its specified price. Now, let&amp;rsquo;s examine the assembly code output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; ; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;__fastcall&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hasEnoughMoney&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; balance)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;hasEnoughMoney&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@@&lt;/span&gt;YA_NH&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;Z proc near      ; Function prologue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; arg_0                &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dword ptr  &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;89&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;C &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;08&lt;/span&gt;          mov     [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_0], ecx           ; Move the balance argument into local stack storage
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001004&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;B &lt;span style=&#34;color:#ae81ff&#34;&gt;05&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;A &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;    mov     eax, cs:&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;masterSwordPrice  ; Load the masterSwordPrice into the EAX &lt;span style=&#34;color:#66d9ef&#34;&gt;register&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00100&lt;/span&gt;A &lt;span style=&#34;color:#ae81ff&#34;&gt;39&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;44&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;08&lt;/span&gt;          cmp     [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_0], eax           ; Compare balance with the masterSwordPrice
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00100&lt;/span&gt;E &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;C &lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt;                jl      &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; loc_140001014        ; Jump  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; balance is less than masterSwordPrice
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001010&lt;/span&gt; B0 &lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;                mov     al, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;          ; Set &lt;span style=&#34;color:#a6e22e&#34;&gt;AL&lt;/span&gt; (the lower &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; bits of RAX) to &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (indicating enough money)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001012&lt;/span&gt; EB &lt;span style=&#34;color:#ae81ff&#34;&gt;02&lt;/span&gt;                jmp     &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; locret_140001016     ; Jump to Function epilogue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001014&lt;/span&gt; ; &lt;span style=&#34;color:#f92672&#34;&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001014&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001014&lt;/span&gt; loc_140001014:                                     ; Jump target &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; balance is insufficient
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001014&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt; C0                xor     al, al                ;  Set AL to &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (indicating insufficient funds)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001016&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001016&lt;/span&gt; locret_140001016:                                  ; Function epilogue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001016&lt;/span&gt; C3                   retn                          ; Return from the function
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001016&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;hasEnoughMoney&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@@&lt;/span&gt;YA_NH&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;Z endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As observed, the &lt;code&gt;hasEnoughMoney&lt;/code&gt; function essentially compares the input balance with the masterSwordPrice and makes conditional jumps based on whether the balance is sufficient or not. Our main focus is on the &lt;code&gt;al&lt;/code&gt; register because it holds the function&amp;rsquo;s return value. If &lt;code&gt;al&lt;/code&gt; is 0, the function returns false. In this case, we examine &lt;code&gt;loc_140001014&lt;/code&gt;, which is the point where the value 0 is placed into the &lt;code&gt;al&lt;/code&gt; register.&lt;/p&gt;
&lt;p&gt;The opcode bytes for &lt;code&gt;xor al, al&lt;/code&gt; are &lt;code&gt;32 C0&lt;/code&gt;, a common and efficient way to zero a register. However, it has the same length as the &lt;code&gt;mov al, 1&lt;/code&gt;, &lt;code&gt;B0 01&lt;/code&gt;. So if we would like to always return true, we replace the &lt;code&gt;xor al, al&lt;/code&gt; with &lt;code&gt;mov al, 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The example was clear and had code that was easy to understand. However, imagine a scenario where you can&amp;rsquo;t locate the part of the code where the comparison takes place. This can happen if the function is extensive, intricate, and also purchases the master sword by subtracting its price from your current balance:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; ; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;__fastcall&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkBalanceAndBuySword&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;balance)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;checkBalanceAndBuySword&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@@&lt;/span&gt;YA_NAEAH&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;Z proc near ; Function prologue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; var_18          &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dword ptr &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; arg_0           &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; qword ptr  &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt;                 mov     [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_0], rcx           ; Move balance argument into local stack storage
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001005&lt;/span&gt;                 sub     rsp, &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h                   ; Allocate space on the stack
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00100&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;                 mov     eax, cs:&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;masterSwordPrice  ; Load masterSwordPrice into EAX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00100F&lt;/span&gt;                 mov     [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_18], eax      ; Store masterSwordPrice on the stack
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001012&lt;/span&gt;                 mov     rax, [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_0]       ; Load the value pointed to by balance into RAX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001017&lt;/span&gt;                 mov     ecx, [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_18]      ; Load masterSwordPrice into ECX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00101&lt;/span&gt;A                 cmp     [rax], ecx                 ; Compare the value pointed to by balance with masterSwordPrice
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00101&lt;/span&gt;C                 jge     &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; loc_140001022        ; Jump &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; greater or &lt;span style=&#34;color:#a6e22e&#34;&gt;equal&lt;/span&gt; (indicating sufficient funds)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00101&lt;/span&gt;E                 xor     al, al                     ; Set AL to &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (indicating insufficient funds)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001020&lt;/span&gt;                 jmp     &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; loc_140001047        ; Function epilogue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001022&lt;/span&gt; ; &lt;span style=&#34;color:#f92672&#34;&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001022&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001022&lt;/span&gt; loc_140001022: ; Jump target &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; balance is sufficient
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001036&lt;/span&gt;                 mov     eax, [rax]                 ; Load the value pointed to by balance into EAX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00103&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;                 sub     eax, ecx                   ; Subtract masterSwordPrice from EAX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00103&lt;/span&gt;A                 mov     rcx, [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_0]       ; Reload balance into RCX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00103F&lt;/span&gt;                 mov     [rcx], eax                 ; Update the value pointed to by balance with the &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; balance
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001041&lt;/span&gt;                 mov     al, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;                      ; Set AL to &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (indicating successful purchase)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001043&lt;/span&gt;                 jmp     &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; loc_140001047        ; Function epilogue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001045&lt;/span&gt; ; &lt;span style=&#34;color:#f92672&#34;&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001045&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001045&lt;/span&gt; loc_140001045:                                     ; Jump target &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; balance is insufficient
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001045&lt;/span&gt;                 xor     al, al                     ; Set AL to &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (indicating insufficient funds)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001047&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001047&lt;/span&gt; loc_140001047: ; Function epilogue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001047&lt;/span&gt;                 add     rsp, &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h                   ; Deallocate stack space
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00104&lt;/span&gt;B                 retn                               ; Return from the function
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00104&lt;/span&gt;B &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;checkBalanceAndBuySword&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@@&lt;/span&gt;YA_NAEAH&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;Z endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;The assembly code snippet has been trimmed to remove unnecessary parts.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This assembly code snippet is much larger and more complex than the previous one, but the key part to focus on is &lt;code&gt;loc_140001022&lt;/code&gt;. Here, the balance is subtracted and updated. Typically, you need to track movements from global variables, like &lt;code&gt;mov eax, cs:?masterSwordPrice&lt;/code&gt;, which eventually ends up in the &lt;code&gt;ecx&lt;/code&gt; register, or observe what happens with the &lt;code&gt;rcx&lt;/code&gt; register, the pointer to our balance. The balance pointer is moved into the stack at &lt;code&gt;[rsp+arg_0]&lt;/code&gt;, later loaded into &lt;code&gt;rax&lt;/code&gt;, and in &lt;code&gt;loc_140001022&lt;/code&gt;, the balance value is read and stored in &lt;code&gt;eax&lt;/code&gt; using &lt;code&gt;mov eax, [rax].&lt;/code&gt; It&amp;rsquo;s evident that &lt;code&gt;sub eax, ecx&lt;/code&gt; calculates the new balance and writes it back into the balance pointer.&lt;/p&gt;
&lt;p&gt;For our purpose of always getting a sword without spending money, we just need to replace &lt;code&gt;jge loc_140001022&lt;/code&gt; with &lt;code&gt;jmp loc_140001022&lt;/code&gt; and &lt;code&gt;sub eax, ecx&lt;/code&gt; with &lt;code&gt;add eax, ecx&lt;/code&gt;. All the opcode bytes are the same length, so replacing a total of 4 bytes is sufficient for unlimited swords and funds.&lt;/p&gt;
&lt;h2 id=&#34;creating-a-pattern&#34;&gt;Creating a pattern&lt;/h2&gt;
&lt;p&gt;Now, we create a suitable pattern for our pattern scanner in our program, which will replace specific bytes. The first pattern we need is for &lt;code&gt;jge loc_140001022&lt;/code&gt;, so that the money addition code runs, regardless of the balance. The opcode bytes &lt;code&gt;7D 04&lt;/code&gt; are quite short, so we combine them with the opcode bytes &lt;code&gt;32 C0 EB 25&lt;/code&gt; from the two assembly instructions below. This results in the final pattern &lt;code&gt;7D 04 32 C0 EB 25&lt;/code&gt;. Technically, we could replace the second and last byte of the pattern with wildcards because the conditional jump offsets might change, but it&amp;rsquo;s highly unlikely that a function solely checking the balance and buying a sword will change in the future.&lt;/p&gt;
&lt;p&gt;As for the &lt;code&gt;sub eax, ecx&lt;/code&gt; with the opcode bytes &lt;code&gt;2B C1&lt;/code&gt;, we add the opcode bytes &lt;code&gt;48 8B 4C 24 20&lt;/code&gt; from the assembly instruction below, resulting in the final pattern &lt;code&gt;2B C1 48 8B 4C 24 20&lt;/code&gt;. These two patterns are unique enough for our program.&lt;/p&gt;
&lt;p&gt;Now, we just need to find the corresponding patched opcode bytes: a &lt;code&gt;jmp loc_140001022&lt;/code&gt; has the opcode bytes &lt;code&gt;EB 04&lt;/code&gt;, and an &lt;code&gt;add eax, ecx&lt;/code&gt; has the opcode bytes &lt;code&gt;01 C8&lt;/code&gt;. That&amp;rsquo;s all there is to it.&lt;/p&gt;
&lt;h2 id=&#34;writing-the-program&#34;&gt;Writing the program&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;I won&amp;rsquo;t provide a detailed explanation of how the Windows API functions work; instead, I&amp;rsquo;ll demonstrate how to use them with an example.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To develop a program that can alter a target process&amp;rsquo;s memory, we need to utilize Windows APIs to initially acquire a handle to the target process with the required permissions to read and write memory.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;DWORD targetProcessID &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1234&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Open the target process with full access.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;HANDLE hProcess &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetProcessID);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Next, we need to obtain the address of the patterns so that we can correctly insert our opcode bytes into the target process at the right location.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; jmpAddress &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getAddressByPattern(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;7D 04 32 C0 EB 25&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; subAddress &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getAddressByPattern(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2B C1 48 8B 4C 24 20&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Now, how do we write?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The only remaining problem is that the &lt;code&gt;.text&lt;/code&gt; section of the target process is not initially writable. Attempting to write to the &lt;code&gt;.text&lt;/code&gt; section will trigger an exception. To address this issue, we must modify the protection of the page by utilizing the &lt;code&gt;VirtualProtectEx&lt;/code&gt; function, perform the necessary write operation, and afterward, restore the page protection to its original state. We can employ the &lt;code&gt;WriteProcessMemory&lt;/code&gt; function to write our data in the specified location within the target process.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Change memory protection to PAGE_EXECUTE_READWRITE.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// We use the for the dwSize subAddress - jmpAddress + 2, because we change the protection from jmpAddress to subAddress + 2 because of the two bytes we have replace at the subAddress.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;DWORD oldProtect;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (VirtualProtectEx(hProcess, (LPVOID)jmpAddress, subAddress &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; jmpAddress &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, PAGE_EXECUTE_READWRITE, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;oldProtect)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//our jmp opcode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; jmpOpcode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xEB\x04&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Write data to the target process.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  SIZE_T bytesWritten;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  WriteProcessMemory(hProcess, (LPVOID)jmpAddress, jmpOpcode, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bytesWritten);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//our sub opcode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; subOpcode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x01\xC8&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Write data to the target process.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  WriteProcessMemory(hProcess, (LPVOID)subAddress, subOpcode, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bytesWritten);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Restore the original memory protection.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  VirtualProtectEx(hProcess, (LPVOID)jmpAddress, subAddress &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; jmpAddress &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, oldProtect, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;oldProtect);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Before patching:
&lt;img src=&#34;https://spuckwaffel.com/blogposts/blogposts/BytePatching-1.png&#34; alt=&#34;Image showing the unpatched program&#34;&gt;&lt;/p&gt;
&lt;p&gt;After patching:
&lt;img src=&#34;https://spuckwaffel.com/blogposts/blogposts/BytePatching-2.png&#34; alt=&#34;Image showing the patched program&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Understanding assembly code and logic is an essential skill when it comes to patching programs. Once you grasp the fundamentals, the process remains consistent. This knowledge is incredibly potent and applicable to a wide range of software, enabling you to circumvent paywalls and enhance your experience in various applications, particularly in offline games. However, a word of caution: in the realm of byte-patching, altering the wrong bytes can lead to the complete failure of the program. Therefore, while it grants great power, it must be wielded with care and responsibility.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>RE-Invent: Signature Scanning</title>
      <link>https://spuckwaffel.com/blogposts/posts/signature-scanning/</link>
      <pubDate>Wed, 13 Sep 2023 16:57:00 +0200</pubDate>
      
      <guid>https://spuckwaffel.com/blogposts/posts/signature-scanning/</guid>
      <description>Disclaimer The RE-Invent blog posts are designed to break down complex information into simpler terms, specifically for beginners learning the basics of Reverse Engineering. These posts are strictly for educational and experimental use and are not intended to target any software. Please ensure to use this knowledge responsibly and in accordance with ethical and legal standards.
Introduction This article expects basic knowledge about sections in applications (.text, .data), offsets and basic assembly knowledge.</description>
      <content>&lt;h2 id=&#34;disclaimer&#34;&gt;Disclaimer&lt;/h2&gt;
&lt;p&gt;The RE-Invent blog posts are designed to break down complex information into simpler terms, specifically for beginners learning the basics of Reverse Engineering. These posts are strictly for educational and experimental use and are not intended to target any software. Please ensure to use this knowledge responsibly and in accordance with ethical and legal standards.&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This article expects basic knowledge about sections in applications (&lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;), offsets and basic assembly knowledge.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the realm of game modification or vulnerability research, you may often encounter functions named &lt;code&gt;pattern_scan&lt;/code&gt; or byte patterns like &lt;code&gt;48 8B 05 ? ? ? ? 48 8B 0C C8 48 8D 04 D1 48 85 C0&lt;/code&gt; in the source code. These mysterious codes seem to return an offset or an address from a called function. More often than not, these addresses point to functions within an application. But why is this the case? Why don’t these applications use the offset directly? And why do these byte patterns contain these &lt;code&gt;?&lt;/code&gt; symbols? Let’s delve into these questions.&lt;/p&gt;
&lt;h2 id=&#34;the-idea&#34;&gt;The Idea&lt;/h2&gt;
&lt;p&gt;To better understand this, let&amp;rsquo;s consider an example: Games need to keep track of various elements during gameplay, such as the number of players in an online game. The game maintains a structure or array that contains all the players in your match, along with basic information about their position, health, ammo, etc. If you want to determine the position of each player, you need to locate the player array stored by the engine. So, our first task is to figure out how the engine accesses these players.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s simplify this with an example: The engine uses specific structures for the players:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Basic player struct
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Player&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; health;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ammo;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Basic Player array
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PlayerArray&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; player1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; player2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; player3;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now the engine has 2 functions for the players:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// A global pointer to the players
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;PlayerArray&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; players;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// A function that allocates bytes for the players
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createPlayerStruct&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//allocate 0x3000 bytes for the players
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    players &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (PlayerArray&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)malloc(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x3000&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Do something...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// A function that gets the Players
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getPlayerOne&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; player1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; players&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;player1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Do something...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As illustrated, the engine initializes the players using the &lt;code&gt;createPlayerStruct&lt;/code&gt; function, and the &lt;code&gt;getPlayerOne&lt;/code&gt; function retrieves the first player. Both of these functions access the global variable &lt;code&gt;PlayerArray* players&lt;/code&gt;. This global variable is located in the &lt;code&gt;.data&lt;/code&gt; section of the engine. Therefore, our objective is to identify where this pointer is within the &lt;code&gt;.data&lt;/code&gt; section and then read the pointer to access the players.&lt;/p&gt;
&lt;p&gt;Now, let&amp;rsquo;s examine an example assembly output of the &lt;code&gt;createPlayerStruct&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00000000000121&lt;/span&gt;BB B9 &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;           mov     ecx, &lt;span style=&#34;color:#ae81ff&#34;&gt;3000&lt;/span&gt;h      ; Size
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00000000000121&lt;/span&gt;C0 FF &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;A F2 &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;        cs:__imp_malloc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00000000000121&lt;/span&gt;C6 &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;89&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;05&lt;/span&gt; A3 AF &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;     mov     cs:&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;players&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;PlayerArray&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;, rax ; PlayerArray &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; players
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00000000000121&lt;/span&gt;CD &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;D A5 C8 &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;     lea     rsp, [rbp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;C8h]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;malloc&lt;/code&gt; function is called and the result is stored in the variable &lt;code&gt;cs:?players@PlayerArray@&lt;/code&gt;, which is our global players variable. If we trace this variable, it leads us to the &lt;code&gt;.data&lt;/code&gt; section of the binary:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.data:&lt;span style=&#34;color:#ae81ff&#34;&gt;000000000001&lt;/span&gt;D170      ; PlayerArray &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;players
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.data:&lt;span style=&#34;color:#ae81ff&#34;&gt;000000000001&lt;/span&gt;D170      &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;players&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;PlayerArray&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt; dq &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     ; DATA XREF: createPlayerStruct(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↑&lt;/span&gt;w
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.data:&lt;span style=&#34;color:#ae81ff&#34;&gt;000000000001&lt;/span&gt;D170                                     ; getPlayerOne(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;B&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↑&lt;/span&gt;r
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There we have our offset: &lt;code&gt;0x1D170&lt;/code&gt;. This offset allows us to read and modify the player array. However, this offset changes with each binary update, which can be problematic if the game updates frequently.&lt;/p&gt;
&lt;p&gt;This is where binary signatures come in handy. We can scan the entire binary for specific byte patterns until we find our &lt;code&gt;createPlayerStruct&lt;/code&gt; function, which moves the &lt;code&gt;malloc&lt;/code&gt; result into the global variable. The byte pattern for the &lt;code&gt;mov&lt;/code&gt; instruction would be &lt;code&gt;48 89 05 A3 AF 00 00&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But this pattern won&amp;rsquo;t work in newer versions as it changes with each binary update. To address this, we use wildcards (&lt;code&gt;?&lt;/code&gt;) in our pattern: &lt;code&gt;48 89 05 ? ? ? ?&lt;/code&gt;. This pattern will work for new updates too!&lt;/p&gt;
&lt;p&gt;The only issue is that this pattern is too short and has many wildcards, so it may match many instructions or random bytes. To solve this, we create a larger pattern by adding bytes from instructions before or after our target instruction. In practise its better to add the bytes from the next instructions: &lt;code&gt;48 89 05 ? ? ? ? 48 8D A5 C8 00 00 00&lt;/code&gt;. We don&amp;rsquo;t need more wildcards as it&amp;rsquo;s rare for the &lt;code&gt;lea&lt;/code&gt; instruction to change. We expand this pattern until we get a single result in the binary. Our current binary pattern is sufficient for my application and works after multiple updates.
The process of obtaining the offset involves a straightforward calculation by the CPU. Let&amp;rsquo;s delve deeper into it: The first three bytes of the &lt;code&gt;mov&lt;/code&gt; instruction (&lt;code&gt;48 89 05&lt;/code&gt;) specify the type of &lt;code&gt;mov&lt;/code&gt; operation, in this case, a &lt;code&gt;mov&lt;/code&gt; from the &lt;code&gt;rax&lt;/code&gt; register into an offset. The remaining bytes (&lt;code&gt;A3 AF 00 00&lt;/code&gt;, or &lt;code&gt;0xAFA3&lt;/code&gt; in hex) represent the offset. This offset is added to the offset of the next instruction (in our example, &lt;code&gt;0x121CD&lt;/code&gt;). So, it&amp;rsquo;s essentially &lt;code&gt;0x121CD + 0xAFA3 = 0x1D170&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we were to write a function for this, it would take a binary pattern as input, get the address, read bytes 4 to 7, and add this to the address of the next instruction.
A pseudocode would look like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getOffset&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Get the address of the specific instruction with additional bytes so we get only one match
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; address &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getAddressByPattern(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;48 89 05 ? ? ? ? 48 8D A5 C8 00 00 00&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// The address variable now contains the memory address where the pattern has ben found.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Normally, theres nothing more we have to do if this is our target destination.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// However in our case, we also want to get the offset of the global variable players.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Get the offset from the 4th - 7th byte
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)(address &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 48 89 05 ? ? ? ? &amp;lt;-- read out the wildcards
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Calculate the real offset
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// + 7 because the mov instrunction is 7 bytes long
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// =&amp;gt; next instrunction is at address + 7
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; address &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; offset;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;With this function, you can effortlessly obtain the offset with each game update. However, bear in mind that if the function you&amp;rsquo;ve created the signature for changes, the signature may break, necessitating its recreation.&lt;/p&gt;
&lt;p&gt;This approach is significantly more efficient than manually searching for the offset and has the added advantage of supporting multiple versions simultaneously. This is why signatures are widely used in game modification applications - they offer a simple and reliable method for finding offsets.&lt;/p&gt;
&lt;p&gt;Pattern scans are frequently used in real-world scenarios for hooking specific functions in games, not only for finding offsets. For instance, game capture programs like Medal or OBS employ these scans to capture a game&amp;rsquo;s video and audio output. They could use pattern scans to locate the target function they need.&lt;/p&gt;
&lt;p&gt;In conclusion, while signature scanning requires some initial setup and occasional updates, its benefits in terms of efficiency, multi-version support, and reliability make it an invaluable tool in the realm of game modification, vulnerability research and much more. It&amp;rsquo;s a testament to the power of automation and smart design in making complex tasks more manageable.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>UEDumper - The all in one Unreal Engine Dumper and editor</title>
      <link>https://spuckwaffel.com/blogposts/posts/uedumper/</link>
      <pubDate>Tue, 29 Aug 2023 17:10:28 +0200</pubDate>
      
      <guid>https://spuckwaffel.com/blogposts/posts/uedumper/</guid>
      <description>Disclaimer UEDumper is intended solely for educational and experiential purposes. It is not designed or intended to target Unreal Engine, its developers, or any associated entities. The project&amp;rsquo;s purpose is to provide a platform for exploring the core functionality of Unreal Engine. Any use of UEDumper outside the scope of educational exploration is strongly discouraged. The developers of UEDumper do not endorse or support any misuse of this tool for unauthorized activities.</description>
      <content>&lt;h2 id=&#34;disclaimer&#34;&gt;Disclaimer&lt;/h2&gt;
&lt;p&gt;UEDumper is intended solely for educational and experiential purposes. It is not designed or intended to target Unreal Engine, its developers, or any associated entities. The project&amp;rsquo;s purpose is to provide a platform for exploring the core functionality of Unreal Engine. Any use of UEDumper outside the scope of educational exploration is strongly discouraged. The developers of UEDumper do not endorse or support any misuse of this tool for unauthorized activities. Always adhere to ethical and legal standards when using UEDumper or any similar tools.&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This article explores the functionalities of UEDumper without delving into the technical details of its inner mechanisms. For those seeking to delve deeper, the source code and assistance can be accessed on &lt;a href=&#34;https://github.com/Spuckwaffel/UEDumper&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Within the realm of Unreal Engine games, the allure of having an SDK generator for your target game lies in the ability to keep your program in sync with the latest updates to structs, classes, and offsets. Yet, this convenience often comes at a cost: the proliferation of hundreds of files, leaving you puzzled about which to include and which to omit from your project.&lt;/p&gt;
&lt;p&gt;Moreover, a recurrent challenge emerges when dealing with pointers within classes — instead of pointing to the actual class, they frequently reference default classes. A prime example surfaces in Epic Games&amp;rsquo; Fortnite, where the PawnPrivate points to APawn rather than the more relevant AFortPlayerPawn.&lt;/p&gt;
&lt;p&gt;Enter UEDumper&amp;rsquo;s groundbreaking solution — a fusion of an SDK editor and Live editor. With this dynamic duo at your disposal, these quandaries find resolution. Seamlessly navigate the intricate pathways of Unreal Engine games, demystify pointers, and identify discrepancies between expected and actual class references. UEDumper shines as a beacon of clarity in the often intricate landscape of mod development.&lt;/p&gt;
&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ve always been intrigued by the inner workings of Unreal Engine SDK generators. The way entire classes can be constructed even in the absence of a .pdb file containing all the necessary structures and classes fascinated me. What struck me even more was the incredible convenience these tools brought to the table when dealing with newly released games – enabling quick modding within a matter of minutes.&lt;/p&gt;
&lt;p&gt;There was a persistent frustration, though. Whenever I wished to test memory modifications or simply read specific values, I found myself laboring to integrate the logic into my program and then painstakingly printing the results. This not only consumed precious time but also placed significant constraints on the depth of exploration possible.&lt;/p&gt;
&lt;p&gt;Adding to this mix was a friend&amp;rsquo;s concept of a &amp;ldquo;live editor&amp;rdquo;, a concept that intrigued me greatly. Although my friend never released their version, the idea stuck with me, eventually pushing me towards creating one myself.&lt;/p&gt;
&lt;p&gt;All these factors converged into the birth of this tool. Originally, I hadn&amp;rsquo;t even planned to release it as an open-source project. However, a desire to provide something of real value to others, something that could genuinely aid in their future development endeavors, led me to share this creation with the community.&lt;/p&gt;
&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;
&lt;p&gt;Getting started with UEDumper is a breeze, especially if you&amp;rsquo;re familiar with the consistent structure found in Unreal Engine games. The way classes, structs, and names are generated tends to follow a similar pattern across titles. Fortunately, the open-source nature of Unreal Engine&amp;rsquo;s code grants you access to its inner workings, enabling you to grasp its core logic.&lt;/p&gt;
&lt;p&gt;In a nutshell, UEDumper capitalizes on Unreal Engine&amp;rsquo;s reflection system to gather essential information. This reflection system possesses the remarkable ability to let a program examine itself during runtime. This capability underpins crucial functionalities in Unreal Engine, ranging from editor detail panels to serialization, garbage collection, network replication, and Blueprint/C++ interactions. It&amp;rsquo;s important to note that standard C++ lacks inherent reflection support, prompting Unreal Engine to develop its own mechanism for harvesting, querying, and manipulating data related to C++ classes, structs, functions, member variables, and enumerations.&lt;/p&gt;
&lt;p&gt;This robust reflection system is embedded within every Unreal Engine game. It empowers you to recreate all the classes and structs painstakingly crafted by game developers and the Unreal Engine team itself. Think of it as an innate built-in editor within Unreal Engine that we can readily leverage through UEDumper.&lt;/p&gt;
&lt;p&gt;Though there are a few essential steps required to get UEDumper up and running, they are relatively straightforward. The offsets known as &lt;code&gt;GNames&lt;/code&gt; and &lt;code&gt;GObjects&lt;/code&gt; stand as crucial elements to launch the dumper and obtain a robust SDK. It&amp;rsquo;s worth noting that while this article won&amp;rsquo;t delve into the process of acquiring these offsets, I plan to address this topic in a separate post.&lt;/p&gt;
&lt;p&gt;In addition, you might need to configure a handful of game-related settings within the specific settings file. Often, these settings are already optimized for the game&amp;rsquo;s requirements. Once you&amp;rsquo;ve secured the necessary offsets and integrated them correctly, along with configuring the relevant settings, you&amp;rsquo;re all set to dive into the process of dumping and generating your very first SDK! These initial steps pave the way for a rewarding journey into exploring the Unreal Engine&amp;rsquo;s intricacies.&lt;/p&gt;
&lt;h2 id=&#34;overview-of-uedumper&#34;&gt;Overview of UEDumper&lt;/h2&gt;
&lt;p&gt;Once your game project is established and an effective SDK is created, the UEDumper tool unfolds with an array of convenient features, streamlining the exploration of your SDK. The Package window, situated on the left, meticulously arranges all game Packages in alphabetical order—excluding the BasicType class housing manually crafted structures and classes. By selecting any package, its contents—comprising classes, structs, functions, and enums — become readily accessible. Each package bears its own unique array of contents, varying in scope and scale.&lt;/p&gt;
&lt;p&gt;Classes and structs come alive with size and offset information alongside their members, rendering effortless comparisons to previous dumps. The presence of &amp;ldquo;unknowndata&amp;rdquo; variables, instances where variables remain undefined or undiscovered, occasionally arises due to struct variable visibility issues in the reflection system. Rectifying this is achievable—simply edit the &amp;ldquo;unknowndata&amp;rdquo; field and define the variable manually. All modifications can be saved, seamlessly synchronizing the live editor and SDK.&lt;/p&gt;
&lt;p&gt;Speaking of saving, the entire project can be preserved, allowing unfettered access to the SDK viewer sans the need for redumping—an invaluable asset for both streamlined browsing and collaborative sharing. Below the packages, a search bar resides, permitting direct queries for classes, structs, functions, and enums, triggering the opening of their corresponding packages.&lt;/p&gt;
&lt;p&gt;On the right side, an assortment of structs, classes, functions, and enums grace the screen. Selection of any index offers an insightful display. Within classes and structs, pinpointing variable members is a cinch, swiftly navigating to the desired location and distinctly marking it for ease.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Below is an image depicting the SDK editor window, revealing a successful SDK generation alongside accessible open packages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://spuckwaffel.com/blogposts/blogposts/UEDumper.png&#34; alt=&#34;Image showing the SDK editor window&#34;&gt;&lt;/p&gt;
&lt;p&gt;When your exploration concludes, project preservation is a snap — save your project to disk, ensuring continuous access to your SDK exploration. The journey through the Unreal Engine&amp;rsquo;s intricacies becomes not only comprehensible but also consistently engaging with UEDumper.&lt;/p&gt;
&lt;h2 id=&#34;live-editor&#34;&gt;Live Editor&lt;/h2&gt;
&lt;p&gt;The live editor stands as a robust instrument, enabling real-time viewing of classes with their data, all without writing a single line of code. With the ability to effortlessly add actual Unreal Engine class addresses, exploration becomes immediately accessible. This dynamic tool seamlessly identifies the class type, streamlining your experience.&lt;/p&gt;
&lt;p&gt;Alternatively, the option to input offsets, such as &lt;code&gt;GWorld&lt;/code&gt; provides a unique advantage. Whenever the current world changes, the world pointer is updated accordingly with all its data.&lt;/p&gt;
&lt;p&gt;Imagine the live editor as a counterpart to the widely recognized tool ReClass, but with an additional layer — predefined classes that eliminate guesswork. Through dedicated use of the live editor, you&amp;rsquo;ll come across the automatic class pointer fix, a feature that addresses the challenge arising from pointers pointing to base classes instead of their actual inheriting classes. In practical terms, this means that variables like &lt;code&gt;APawn* PawnPrivate&lt;/code&gt; in the SDK/Reflection system are transformed into their more descriptive counterparts like &lt;code&gt;AFortPlayerPawn* PawnPrivate&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The live editor&amp;rsquo;s capacity to address this issue becomes especially valuable when crafting mods. It clarifies what data is truly accessible and what isn&amp;rsquo;t — an essential aspect for mod creation. Moreover, this tool isn&amp;rsquo;t limited to observation alone; it allows direct value manipulation for various data types. Furthermore, support for enums is built-in, complete with their designated names, and even a color picker is at your disposal for seamless modifications.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You will find a video link at the bottom of the GitHub readme showcasing the live editor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In conclusion, UEDumper emerges as a powerful companion for all Unreal Engine enthusiasts, offering a streamlined approach to exploring the inner workings of the engine, even down to real-time manipulation. While this article has provided a glimpse into its capabilities, the true potential lies in your hands as you dive into the repository.&lt;/p&gt;
&lt;p&gt;Feel free to explore the UEDumper repository on &lt;a href=&#34;https://github.com/Spuckwaffel/UEDumper&#34;&gt;GitHub&lt;/a&gt; to access its source code and tap into a wealth of resources. It&amp;rsquo;s important to note that UEDumper is an actively maintained project, evolving with the ever-changing landscape of game development. With an engaged community around it, you&amp;rsquo;ll find support, updates, and discussions that can enhance your journey into the heart of Unreal Engine.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
