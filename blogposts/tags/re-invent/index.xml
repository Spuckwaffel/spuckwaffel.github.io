<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RE-Invent on Spuckwaffels Blog</title>
    <link>https://spuckwaffel.com/blogposts/tags/re-invent/</link>
    <description>Recent content in RE-Invent on Spuckwaffels Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Spuckwaffel</copyright>
    <lastBuildDate>Tue, 24 Oct 2023 00:57:31 +0200</lastBuildDate><atom:link href="https://spuckwaffel.com/blogposts/tags/re-invent/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RE-Invent: Byte Patching functions for unfair advantages</title>
      <link>https://spuckwaffel.com/blogposts/posts/byte-patching/</link>
      <pubDate>Tue, 24 Oct 2023 00:57:31 +0200</pubDate>
      
      <guid>https://spuckwaffel.com/blogposts/posts/byte-patching/</guid>
      <description>Disclaimer The RE-Invent blog posts are designed to break down complex information into simpler terms, specifically for beginners learning the basics of Reverse Engineering. These posts are strictly for educational and experimental use and are not intended to target any software. Please ensure to use this knowledge responsibly and in accordance with ethical and legal standards.
Introduction This article expects basic knowledge about sections in applications (.text, .data), offsets, assembly and debugging knowledge.</description>
      <content>&lt;h2 id=&#34;disclaimer&#34;&gt;Disclaimer&lt;/h2&gt;
&lt;p&gt;The RE-Invent blog posts are designed to break down complex information into simpler terms, specifically for beginners learning the basics of Reverse Engineering. These posts are strictly for educational and experimental use and are not intended to target any software. Please ensure to use this knowledge responsibly and in accordance with ethical and legal standards.&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This article expects basic knowledge about sections in applications (&lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;), offsets, assembly and debugging knowledge.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Many of us have experienced being stuck in a video game, unable to progress due to resource limitations or not having enough coins to purchase valuable items. Similarly, if you&amp;rsquo;ve ever wanted to use a program beyond its free trial period without paying, you might have wondered about the complexity of manipulating the program to achieve your goal. Large programs can be very intricate, making it challenging for beginners to locate the function responsible for time or coin management. So, where do you begin, and once you succeed, how can you create a program that automatically applies these changes? Let&amp;rsquo;s explore this.&lt;/p&gt;
&lt;h2 id=&#34;goals&#34;&gt;Goals&lt;/h2&gt;
&lt;p&gt;Lets split up our final goal into smaller sections.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Finding the corresponding function and assembly code that checks the coin balance or the time via debugging or reading the programs&amp;rsquo; code&lt;/li&gt;
&lt;li&gt;Creating a pattern so we always find the bytes we have to replace&lt;/li&gt;
&lt;li&gt;Writing a program to write the bytes&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;finding-the-function&#34;&gt;Finding the function&lt;/h2&gt;
&lt;p&gt;To begin, let&amp;rsquo;s first figure out where we need to make changes to a function to achieve the desired result. Consider a program that verifies whether you have sufficient funds to purchase the master sword.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//target price stored somewhere in memory
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; masterSwordPrice &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5000&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//function that checks if the balance is enough to buy the sword
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hasEnoughMoney&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; balance)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (balance &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; masterSwordPrice)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;buyMasterSword&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//get our current balance
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; currentBalance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(hasEnoughMoney(currentBalance))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		puts(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Buying the sword...&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		puts(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Not enough money...&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If a user lacks the required funds, they can&amp;rsquo;t purchase the master sword and will receive the message &amp;ldquo;Not enough money&amp;hellip;&amp;rdquo; instead. The critical part here is the &lt;code&gt;hasEnoughMoney&lt;/code&gt; function, which checks if the user has sufficient funds to buy the sword at its specified price. Now, let&amp;rsquo;s examine the assembly code output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; ; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;__fastcall&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hasEnoughMoney&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; balance)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;hasEnoughMoney&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@@&lt;/span&gt;YA_NH&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;Z proc near      ; Function prologue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; arg_0                &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dword ptr  &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;89&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;C &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;08&lt;/span&gt;          mov     [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_0], ecx           ; Move the balance argument into local stack storage
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001004&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;B &lt;span style=&#34;color:#ae81ff&#34;&gt;05&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;A &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;    mov     eax, cs:&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;masterSwordPrice  ; Load the masterSwordPrice into the EAX &lt;span style=&#34;color:#66d9ef&#34;&gt;register&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00100&lt;/span&gt;A &lt;span style=&#34;color:#ae81ff&#34;&gt;39&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;44&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;08&lt;/span&gt;          cmp     [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_0], eax           ; Compare balance with the masterSwordPrice
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00100&lt;/span&gt;E &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;C &lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt;                jl      &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; loc_140001014        ; Jump  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; balance is less than masterSwordPrice
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001010&lt;/span&gt; B0 &lt;span style=&#34;color:#ae81ff&#34;&gt;01&lt;/span&gt;                mov     al, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;          ; Set &lt;span style=&#34;color:#a6e22e&#34;&gt;AL&lt;/span&gt; (the lower &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; bits of RAX) to &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (indicating enough money)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001012&lt;/span&gt; EB &lt;span style=&#34;color:#ae81ff&#34;&gt;02&lt;/span&gt;                jmp     &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; locret_140001016     ; Jump to Function epilogue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001014&lt;/span&gt; ; &lt;span style=&#34;color:#f92672&#34;&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001014&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001014&lt;/span&gt; loc_140001014:                                     ; Jump target &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; balance is insufficient
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001014&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt; C0                xor     al, al                ;  Set AL to &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (indicating insufficient funds)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001016&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001016&lt;/span&gt; locret_140001016:                                  ; Function epilogue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001016&lt;/span&gt; C3                   retn                          ; Return from the function
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001016&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;hasEnoughMoney&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@@&lt;/span&gt;YA_NH&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;Z endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As observed, the &lt;code&gt;hasEnoughMoney&lt;/code&gt; function essentially compares the input balance with the masterSwordPrice and makes conditional jumps based on whether the balance is sufficient or not. Our main focus is on the &lt;code&gt;al&lt;/code&gt; register because it holds the function&amp;rsquo;s return value. If &lt;code&gt;al&lt;/code&gt; is 0, the function returns false. In this case, we examine &lt;code&gt;loc_140001014&lt;/code&gt;, which is the point where the value 0 is placed into the &lt;code&gt;al&lt;/code&gt; register.&lt;/p&gt;
&lt;p&gt;The opcode bytes for &lt;code&gt;xor al, al&lt;/code&gt; are &lt;code&gt;32 C0&lt;/code&gt;, a common and efficient way to zero a register. However, it has the same length as the &lt;code&gt;mov al, 1&lt;/code&gt;, &lt;code&gt;B0 01&lt;/code&gt;. So if we would like to always return true, we replace the &lt;code&gt;xor al, al&lt;/code&gt; with &lt;code&gt;mov al, 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The example was clear and had code that was easy to understand. However, imagine a scenario where you can&amp;rsquo;t locate the part of the code where the comparison takes place. This can happen if the function is extensive, intricate, and also purchases the master sword by subtracting its price from your current balance:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; ; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;__fastcall&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkBalanceAndBuySword&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;balance)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;checkBalanceAndBuySword&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@@&lt;/span&gt;YA_NAEAH&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;Z proc near ; Function prologue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; var_18          &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dword ptr &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt; arg_0           &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; qword ptr  &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001000&lt;/span&gt;                 mov     [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_0], rcx           ; Move balance argument into local stack storage
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001005&lt;/span&gt;                 sub     rsp, &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h                   ; Allocate space on the stack
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00100&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;                 mov     eax, cs:&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;masterSwordPrice  ; Load masterSwordPrice into EAX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00100F&lt;/span&gt;                 mov     [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_18], eax      ; Store masterSwordPrice on the stack
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001012&lt;/span&gt;                 mov     rax, [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_0]       ; Load the value pointed to by balance into RAX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001017&lt;/span&gt;                 mov     ecx, [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;var_18]      ; Load masterSwordPrice into ECX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00101&lt;/span&gt;A                 cmp     [rax], ecx                 ; Compare the value pointed to by balance with masterSwordPrice
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00101&lt;/span&gt;C                 jge     &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; loc_140001022        ; Jump &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; greater or &lt;span style=&#34;color:#a6e22e&#34;&gt;equal&lt;/span&gt; (indicating sufficient funds)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00101&lt;/span&gt;E                 xor     al, al                     ; Set AL to &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (indicating insufficient funds)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001020&lt;/span&gt;                 jmp     &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; loc_140001047        ; Function epilogue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001022&lt;/span&gt; ; &lt;span style=&#34;color:#f92672&#34;&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001022&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001022&lt;/span&gt; loc_140001022: ; Jump target &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; balance is sufficient
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001036&lt;/span&gt;                 mov     eax, [rax]                 ; Load the value pointed to by balance into EAX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00103&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;                 sub     eax, ecx                   ; Subtract masterSwordPrice from EAX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00103&lt;/span&gt;A                 mov     rcx, [rsp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;arg_0]       ; Reload balance into RCX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00103F&lt;/span&gt;                 mov     [rcx], eax                 ; Update the value pointed to by balance with the &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; balance
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001041&lt;/span&gt;                 mov     al, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;                      ; Set AL to &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (indicating successful purchase)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001043&lt;/span&gt;                 jmp     &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; loc_140001047        ; Function epilogue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001045&lt;/span&gt; ; &lt;span style=&#34;color:#f92672&#34;&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001045&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001045&lt;/span&gt; loc_140001045:                                     ; Jump target &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; balance is insufficient
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001045&lt;/span&gt;                 xor     al, al                     ; Set AL to &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (indicating insufficient funds)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001047&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001047&lt;/span&gt; loc_140001047: ; Function epilogue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;001047&lt;/span&gt;                 add     rsp, &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;h                   ; Deallocate stack space
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00104&lt;/span&gt;B                 retn                               ; Return from the function
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00104&lt;/span&gt;B &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;checkBalanceAndBuySword&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@@&lt;/span&gt;YA_NAEAH&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;Z endp
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;The assembly code snippet has been trimmed to remove unnecessary parts.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This assembly code snippet is much larger and more complex than the previous one, but the key part to focus on is &lt;code&gt;loc_140001022&lt;/code&gt;. Here, the balance is subtracted and updated. Typically, you need to track movements from global variables, like &lt;code&gt;mov eax, cs:?masterSwordPrice&lt;/code&gt;, which eventually ends up in the &lt;code&gt;ecx&lt;/code&gt; register, or observe what happens with the &lt;code&gt;rcx&lt;/code&gt; register, the pointer to our balance. The balance pointer is moved into the stack at &lt;code&gt;[rsp+arg_0]&lt;/code&gt;, later loaded into &lt;code&gt;rax&lt;/code&gt;, and in &lt;code&gt;loc_140001022&lt;/code&gt;, the balance value is read and stored in &lt;code&gt;eax&lt;/code&gt; using &lt;code&gt;mov eax, [rax].&lt;/code&gt; It&amp;rsquo;s evident that &lt;code&gt;sub eax, ecx&lt;/code&gt; calculates the new balance and writes it back into the balance pointer.&lt;/p&gt;
&lt;p&gt;For our purpose of always getting a sword without spending money, we just need to replace &lt;code&gt;jge loc_140001022&lt;/code&gt; with &lt;code&gt;jmp loc_140001022&lt;/code&gt; and &lt;code&gt;sub eax, ecx&lt;/code&gt; with &lt;code&gt;add eax, ecx&lt;/code&gt;. All the opcode bytes are the same length, so replacing a total of 4 bytes is sufficient for unlimited swords and funds.&lt;/p&gt;
&lt;h2 id=&#34;creating-a-pattern&#34;&gt;Creating a pattern&lt;/h2&gt;
&lt;p&gt;Now, we create a suitable pattern for our pattern scanner in our program, which will replace specific bytes. The first pattern we need is for &lt;code&gt;jge loc_140001022&lt;/code&gt;, so that the money addition code runs, regardless of the balance. The opcode bytes &lt;code&gt;7D 04&lt;/code&gt; are quite short, so we combine them with the opcode bytes &lt;code&gt;32 C0 EB 25&lt;/code&gt; from the two assembly instructions below. This results in the final pattern &lt;code&gt;7D 04 32 C0 EB 25&lt;/code&gt;. Technically, we could replace the second and last byte of the pattern with wildcards because the conditional jump offsets might change, but it&amp;rsquo;s highly unlikely that a function solely checking the balance and buying a sword will change in the future.&lt;/p&gt;
&lt;p&gt;As for the &lt;code&gt;sub eax, ecx&lt;/code&gt; with the opcode bytes &lt;code&gt;2B C1&lt;/code&gt;, we add the opcode bytes &lt;code&gt;48 8B 4C 24 20&lt;/code&gt; from the assembly instruction below, resulting in the final pattern &lt;code&gt;2B C1 48 8B 4C 24 20&lt;/code&gt;. These two patterns are unique enough for our program.&lt;/p&gt;
&lt;p&gt;Now, we just need to find the corresponding patched opcode bytes: a &lt;code&gt;jmp loc_140001022&lt;/code&gt; has the opcode bytes &lt;code&gt;EB 04&lt;/code&gt;, and an &lt;code&gt;add eax, ecx&lt;/code&gt; has the opcode bytes &lt;code&gt;01 C8&lt;/code&gt;. That&amp;rsquo;s all there is to it.&lt;/p&gt;
&lt;h2 id=&#34;writing-the-program&#34;&gt;Writing the program&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;I won&amp;rsquo;t provide a detailed explanation of how the Windows API functions work; instead, I&amp;rsquo;ll demonstrate how to use them with an example.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To develop a program that can alter a target process&amp;rsquo;s memory, we need to utilize Windows APIs to initially acquire a handle to the target process with the required permissions to read and write memory.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;DWORD targetProcessID &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1234&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Open the target process with full access.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;HANDLE hProcess &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetProcessID);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Next, we need to obtain the address of the patterns so that we can correctly insert our opcode bytes into the target process at the right location.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; jmpAddress &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getAddressByPattern(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;7D 04 32 C0 EB 25&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; subAddress &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getAddressByPattern(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2B C1 48 8B 4C 24 20&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Now, how do we write?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The only remaining problem is that the &lt;code&gt;.text&lt;/code&gt; section of the target process is not initially writable. Attempting to write to the &lt;code&gt;.text&lt;/code&gt; section will trigger an exception. To address this issue, we must modify the protection of the page by utilizing the &lt;code&gt;VirtualProtectEx&lt;/code&gt; function, perform the necessary write operation, and afterward, restore the page protection to its original state. We can employ the &lt;code&gt;WriteProcessMemory&lt;/code&gt; function to write our data in the specified location within the target process.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Change memory protection to PAGE_EXECUTE_READWRITE.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// We use the for the dwSize subAddress - jmpAddress + 2, because we change the protection from jmpAddress to subAddress + 2 because of the two bytes we have replace at the subAddress.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;DWORD oldProtect;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (VirtualProtectEx(hProcess, (LPVOID)jmpAddress, subAddress &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; jmpAddress &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, PAGE_EXECUTE_READWRITE, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;oldProtect)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//our jmp opcode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; jmpOpcode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xEB\x04&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Write data to the target process.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  SIZE_T bytesWritten;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  WriteProcessMemory(hProcess, (LPVOID)jmpAddress, jmpOpcode, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bytesWritten);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//our sub opcode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; subOpcode &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x01\xC8&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Write data to the target process.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  WriteProcessMemory(hProcess, (LPVOID)subAddress, subOpcode, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bytesWritten);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Restore the original memory protection.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  VirtualProtectEx(hProcess, (LPVOID)jmpAddress, subAddress &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; jmpAddress &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, oldProtect, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;oldProtect);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Before patching:
&lt;img src=&#34;https://spuckwaffel.com/blogposts/blogposts/BytePatching-1.png&#34; alt=&#34;Image showing the unpatched program&#34;&gt;&lt;/p&gt;
&lt;p&gt;After patching:
&lt;img src=&#34;https://spuckwaffel.com/blogposts/blogposts/BytePatching-2.png&#34; alt=&#34;Image showing the patched program&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Understanding assembly code and logic is an essential skill when it comes to patching programs. Once you grasp the fundamentals, the process remains consistent. This knowledge is incredibly potent and applicable to a wide range of software, enabling you to circumvent paywalls and enhance your experience in various applications, particularly in offline games. However, a word of caution: in the realm of byte-patching, altering the wrong bytes can lead to the complete failure of the program. Therefore, while it grants great power, it must be wielded with care and responsibility.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>RE-Invent: Signature Scanning</title>
      <link>https://spuckwaffel.com/blogposts/posts/signature-scanning/</link>
      <pubDate>Wed, 13 Sep 2023 16:57:00 +0200</pubDate>
      
      <guid>https://spuckwaffel.com/blogposts/posts/signature-scanning/</guid>
      <description>Disclaimer The RE-Invent blog posts are designed to break down complex information into simpler terms, specifically for beginners learning the basics of Reverse Engineering. These posts are strictly for educational and experimental use and are not intended to target any software. Please ensure to use this knowledge responsibly and in accordance with ethical and legal standards.
Introduction This article expects basic knowledge about sections in applications (.text, .data), offsets and basic assembly knowledge.</description>
      <content>&lt;h2 id=&#34;disclaimer&#34;&gt;Disclaimer&lt;/h2&gt;
&lt;p&gt;The RE-Invent blog posts are designed to break down complex information into simpler terms, specifically for beginners learning the basics of Reverse Engineering. These posts are strictly for educational and experimental use and are not intended to target any software. Please ensure to use this knowledge responsibly and in accordance with ethical and legal standards.&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This article expects basic knowledge about sections in applications (&lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;), offsets and basic assembly knowledge.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the realm of game modification or vulnerability research, you may often encounter functions named &lt;code&gt;pattern_scan&lt;/code&gt; or byte patterns like &lt;code&gt;48 8B 05 ? ? ? ? 48 8B 0C C8 48 8D 04 D1 48 85 C0&lt;/code&gt; in the source code. These mysterious codes seem to return an offset or an address from a called function. More often than not, these addresses point to functions within an application. But why is this the case? Why don’t these applications use the offset directly? And why do these byte patterns contain these &lt;code&gt;?&lt;/code&gt; symbols? Let’s delve into these questions.&lt;/p&gt;
&lt;h2 id=&#34;the-idea&#34;&gt;The Idea&lt;/h2&gt;
&lt;p&gt;To better understand this, let&amp;rsquo;s consider an example: Games need to keep track of various elements during gameplay, such as the number of players in an online game. The game maintains a structure or array that contains all the players in your match, along with basic information about their position, health, ammo, etc. If you want to determine the position of each player, you need to locate the player array stored by the engine. So, our first task is to figure out how the engine accesses these players.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s simplify this with an example: The engine uses specific structures for the players:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Basic player struct
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Player&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; health;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ammo;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Basic Player array
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PlayerArray&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; player1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; player2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; player3;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now the engine has 2 functions for the players:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// A global pointer to the players
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;PlayerArray&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; players;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// A function that allocates bytes for the players
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createPlayerStruct&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//allocate 0x3000 bytes for the players
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    players &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (PlayerArray&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)malloc(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x3000&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Do something...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// A function that gets the Players
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getPlayerOne&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Player&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; player1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; players&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;player1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Do something...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As illustrated, the engine initializes the players using the &lt;code&gt;createPlayerStruct&lt;/code&gt; function, and the &lt;code&gt;getPlayerOne&lt;/code&gt; function retrieves the first player. Both of these functions access the global variable &lt;code&gt;PlayerArray* players&lt;/code&gt;. This global variable is located in the &lt;code&gt;.data&lt;/code&gt; section of the engine. Therefore, our objective is to identify where this pointer is within the &lt;code&gt;.data&lt;/code&gt; section and then read the pointer to access the players.&lt;/p&gt;
&lt;p&gt;Now, let&amp;rsquo;s examine an example assembly output of the &lt;code&gt;createPlayerStruct&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00000000000121&lt;/span&gt;BB B9 &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;           mov     ecx, &lt;span style=&#34;color:#ae81ff&#34;&gt;3000&lt;/span&gt;h      ; Size
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00000000000121&lt;/span&gt;C0 FF &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;A F2 &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;        cs:__imp_malloc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00000000000121&lt;/span&gt;C6 &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;89&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;05&lt;/span&gt; A3 AF &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;     mov     cs:&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;players&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;PlayerArray&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;, rax ; PlayerArray &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; players
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.text:&lt;span style=&#34;color:#ae81ff&#34;&gt;00000000000121&lt;/span&gt;CD &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;D A5 C8 &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;     lea     rsp, [rbp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;C8h]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;malloc&lt;/code&gt; function is called and the result is stored in the variable &lt;code&gt;cs:?players@PlayerArray@&lt;/code&gt;, which is our global players variable. If we trace this variable, it leads us to the &lt;code&gt;.data&lt;/code&gt; section of the binary:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.data:&lt;span style=&#34;color:#ae81ff&#34;&gt;000000000001&lt;/span&gt;D170      ; PlayerArray &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;players
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.data:&lt;span style=&#34;color:#ae81ff&#34;&gt;000000000001&lt;/span&gt;D170      &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;players&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;PlayerArray&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt; dq &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;     ; DATA XREF: createPlayerStruct(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↑&lt;/span&gt;w
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.data:&lt;span style=&#34;color:#ae81ff&#34;&gt;000000000001&lt;/span&gt;D170                                     ; getPlayerOne(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;B&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↑&lt;/span&gt;r
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There we have our offset: &lt;code&gt;0x1D170&lt;/code&gt;. This offset allows us to read and modify the player array. However, this offset changes with each binary update, which can be problematic if the game updates frequently.&lt;/p&gt;
&lt;p&gt;This is where binary signatures come in handy. We can scan the entire binary for specific byte patterns until we find our &lt;code&gt;createPlayerStruct&lt;/code&gt; function, which moves the &lt;code&gt;malloc&lt;/code&gt; result into the global variable. The byte pattern for the &lt;code&gt;mov&lt;/code&gt; instruction would be &lt;code&gt;48 89 05 A3 AF 00 00&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But this pattern won&amp;rsquo;t work in newer versions as it changes with each binary update. To address this, we use wildcards (&lt;code&gt;?&lt;/code&gt;) in our pattern: &lt;code&gt;48 89 05 ? ? ? ?&lt;/code&gt;. This pattern will work for new updates too!&lt;/p&gt;
&lt;p&gt;The only issue is that this pattern is too short and has many wildcards, so it may match many instructions or random bytes. To solve this, we create a larger pattern by adding bytes from instructions before or after our target instruction. In practise its better to add the bytes from the next instructions: &lt;code&gt;48 89 05 ? ? ? ? 48 8D A5 C8 00 00 00&lt;/code&gt;. We don&amp;rsquo;t need more wildcards as it&amp;rsquo;s rare for the &lt;code&gt;lea&lt;/code&gt; instruction to change. We expand this pattern until we get a single result in the binary. Our current binary pattern is sufficient for my application and works after multiple updates.
The process of obtaining the offset involves a straightforward calculation by the CPU. Let&amp;rsquo;s delve deeper into it: The first three bytes of the &lt;code&gt;mov&lt;/code&gt; instruction (&lt;code&gt;48 89 05&lt;/code&gt;) specify the type of &lt;code&gt;mov&lt;/code&gt; operation, in this case, a &lt;code&gt;mov&lt;/code&gt; from the &lt;code&gt;rax&lt;/code&gt; register into an offset. The remaining bytes (&lt;code&gt;A3 AF 00 00&lt;/code&gt;, or &lt;code&gt;0xAFA3&lt;/code&gt; in hex) represent the offset. This offset is added to the offset of the next instruction (in our example, &lt;code&gt;0x121CD&lt;/code&gt;). So, it&amp;rsquo;s essentially &lt;code&gt;0x121CD + 0xAFA3 = 0x1D170&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we were to write a function for this, it would take a binary pattern as input, get the address, read bytes 4 to 7, and add this to the address of the next instruction.
A pseudocode would look like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getOffset&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Get the address of the specific instruction with additional bytes so we get only one match
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; address &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getAddressByPattern(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;48 89 05 ? ? ? ? 48 8D A5 C8 00 00 00&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// The address variable now contains the memory address where the pattern has ben found.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Normally, theres nothing more we have to do if this is our target destination.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// However in our case, we also want to get the offset of the global variable players.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Get the offset from the 4th - 7th byte
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)(address &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 48 89 05 ? ? ? ? &amp;lt;-- read out the wildcards
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Calculate the real offset
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// + 7 because the mov instrunction is 7 bytes long
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// =&amp;gt; next instrunction is at address + 7
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; address &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; offset;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;With this function, you can effortlessly obtain the offset with each game update. However, bear in mind that if the function you&amp;rsquo;ve created the signature for changes, the signature may break, necessitating its recreation.&lt;/p&gt;
&lt;p&gt;This approach is significantly more efficient than manually searching for the offset and has the added advantage of supporting multiple versions simultaneously. This is why signatures are widely used in game modification applications - they offer a simple and reliable method for finding offsets.&lt;/p&gt;
&lt;p&gt;Pattern scans are frequently used in real-world scenarios for hooking specific functions in games, not only for finding offsets. For instance, game capture programs like Medal or OBS employ these scans to capture a game&amp;rsquo;s video and audio output. They could use pattern scans to locate the target function they need.&lt;/p&gt;
&lt;p&gt;In conclusion, while signature scanning requires some initial setup and occasional updates, its benefits in terms of efficiency, multi-version support, and reliability make it an invaluable tool in the realm of game modification, vulnerability research and much more. It&amp;rsquo;s a testament to the power of automation and smart design in making complex tasks more manageable.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
